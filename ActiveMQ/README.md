# :speech_balloon:ActiveMQ

[ActiveMQ](https://github.com/apache/activemq)是由Apache基金会开发的一款消息中间件，基于Java，符合JMS(Java Message Service)规范，支持多种语言和多种协议

# 问题背景

微服务架构之后，链式调用是我们在写程序时的一般流程，为了完成一个整体功能会将其拆分成多个函数（或子模块）<br>
比如模块A调用模块B，模块B调用模块C，模块C调用模块D<br>
但是在大型分布式应用中，系统间的RPC交互繁杂，一个功能背后要调用上百个接口并非不可能<br>
那么这种情况下，从单机架构过渡到分布式微服务架构会存在什么样的问题？

- **系统之间接口耦合比较严重：**

  每新增一个下游功能，都要对上游的相关接口进行改造

  例如系统A要发送数据给系统B和C，发送每个系统的数据可能有差异，因此系统A对要发送给每个系统的数据进行了组装，然后逐一发送。

  当代码上线后有新增了一个需求：把数据也要发送给系统D

  此时就需要修改系统A，让它感知到系统D的存在。如此一来效率十分低下

- **面对大流量并发时，容易被冲垮：**

  每个接口模块的吞吐能力是有限的，当流量大于其上限时，系统就会被冲垮瘫痪

  例如秒杀系统，上游系统发起下单购买操作，下游系统完成秒杀业务逻辑（读取订单，检查库存，冻结库存，检查余额，冻结余额，生成订单，余额扣除，库存扣除，生成流水，余额解冻，库存解冻）

  下游任务繁重，任意一个环节出了差错都会导致整个系统瘫痪

- **等待同步存在性能问题：**

  RPC接口基本上是同步调用，整体的服务性能遵循“木桶理论”，即整体的系统耗时取决于链路中最慢的那个接口。任意一个接口性能低下，会导致整个系统性能低下

# MOM消息中间件

为了解决上述的问题，设计满足以下特点的系统：

1. **能够解耦**：要做到系统解耦，当新的模块进来时，可以做到代码改动最小
2. **能够削峰**：设置流量缓冲池，可以让后端系统按照自身吞吐能力进行消费，不被冲垮
3. **能够异步**：强弱依赖梳理能够将非关键调用链路的操作异步化，以此提升系统整体性能

面向消息的中间件（Message-oriented middleware）能够很好的解决以上问题：

它利用高效可靠的消息传递机制进行与平台无关的数据交流，并基于数据通信来进行分布式系统集成

通过提供**消息传递**和**消息队列**模型在分布式环境下提供应用解耦、弹性伸缩、冗余存储、流量削峰、异步通信、数据同步等功能。

大致过程如下：

发送者（producer）把消息（message）发送给消息服务器（server），消息服务器将消息存放在若干 **队列（queue）/主题（topic）** 中，在适合的时候，消息服务器会将消息转发给接收者（receiver）。在这个过程中，**发送和接受是异步的**，也就是发送无需等待，而发送者和接收者的生命周期也没有必然联系。

尤其是在发布（pub）/订阅（sub）模式下，也可以完成一对多的通信

# 两种消息传递方式

## 点对点传递（队列Queue，发送/接受模式）

1. 每个消息只能有一个消费者，类似一对一的关系。例如自己去领自己的快递
2. 消息的生产者和消费者之间**没有时间上的相关性**，无论消费者在生产者发送消息的时候是否处于运行状态，消费者都可以提取消息。例如发短信时，接收方并不一定会立即查看
3. 消息被消费（接收）后队列**不会再存储**，所以消费者**不会消费到已经被消费掉的消息**。例如，快递取走了就没有了，后面的人不会再取到了

## 一对多传递（主题Topic，发布/订阅模式）

1. 生产者将消息发布到topic中，每个消息可以有多个消费者
2. 生产者和消费者之间**有时间上的相关性**，订阅某一个主题的消费者只能消费**自它订阅后发布的消息**
3. 生产者生产时，topic**不保存消息**，它是**无状态**的，若无人订阅就去生产，那就是一条废消息。所以，一般先启动消费者再启动生产者

JMS规范允许客户创建持久订阅，这在一定程度上放松了时间上的相关性要求。持久订阅允许消费者消费它在未处于激活状态时发送的消息。类似订阅微信公众号，不在线时也会收到更新推送

## 总结

|            |                        Topic模式队列                         |                        Queue模式队列                         |
| ---------- | :----------------------------------------------------------: | :----------------------------------------------------------: |
| 工作模式   | “发布/订阅”模式，如果当前没有订阅者，消息将会被丢弃。如果有多个订阅者，那么这些订阅者都会收到消息 | “负载均衡”模式，如果当前没有消费者，消息也不会丢弃；如果有多个消费者，那么一条消息也只会发送给其中的一个消费者；并且要求消费者ack消息 |
| 有无状态   |                            无状态                            | Queue数据默认会在MQ服务器上以文件形式保存，比如ActiveMQ一般保存在$AMQ_HOME\data\kr-store\data下面，也可以配置成DB存储 |
| 传递完整性 |                 如果没有订阅者，消息会被丢弃                 |                        消息不会被丢弃                        |
| 处理效率   | 由于消息要按照订阅者的数量进行复制，所以处理性能会随着订阅者的增加而明显降低，并且还要结合不同消息协议自身性能的差异 | 由于一条消息只能发送给一个消费者，所以就算消费者再多，性能也不会有明显地降低，当然不同消息协议的具体性能也是有差异的 |



# 参考资料

> 尚硅谷消息中间件之ActiveMQ，周阳
>
> [Apache ActiveMQ官网](https://activemq.apache.org/index.html)
